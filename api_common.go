
/*
 * 共通資料-公共運輸
 *
 *  --- ##### API線上說明(Swagger UI)使用流程與注意事項： 1. 若不使用API金鑰呼叫API，則僅能透過瀏覽器呼叫`【基礎】`服務 ，且每個呼叫來源端IP的上限為每日50次。 2. `【進階】`、`【加值】`、`【歷史】`、`【MaaS】`服務需加入會員並取得API金鑰之後才能使用。 3. 欲使用API金鑰呼叫API，需[註冊為TDX會員](/register)，並於會員中心取得API金鑰。 4. 註冊為會員之後，至[【會員專區-資料服務-服務金鑰】](/user/dataservice/key)功能頁面，從預設金鑰(或建立新的金鑰)取得Client Id和Client Secret資訊。 5. 點選Swagger UI上的Authorize按鈕，依指示填入Client Id和Client Secret資訊並進行驗證，驗證完成後可開始於Swagger UI使用API。 6. 欲透過程式介接API，可參考[範例程式](https://github.com/tdxmotc/SampleCode)。 7. 為確保系統資源使用的合理分配與避免遭受濫用，於Swagger UI上使用API與程式介接API的行為將被記錄並定期做檢視。  ##### API呼叫次數限制: 1. 若不使用API金鑰呼叫API，則僅能透過瀏覽器呼叫`【基礎】`服務 ，且每個呼叫來源端IP的上限為每日50次。 2. 使用API金鑰呼叫API，每個呼叫來源端IP呼叫次數限制為50次/秒 (無每日上限)。  API OAS文本 :[請點我](https://tdx.transportdata.tw/webapi/File/Swagger/V3/9aa23880-013d-4919-be46-3d748d7001e4)
 *
 * API version: v3
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type CommonApiService service
/*
CommonApiService 取得業管機關資料
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format 指定來源格式
 * @param optional nil or *CommonApiBasicApiAuthority2160Opts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.String) -  跳過前幾筆
@return []PtxServiceDtoSharedSpecificationV2BaseAuthority
*/

type CommonApiBasicApiAuthority2160Opts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.String
}

func (a *CommonApiService) BasicApiAuthority2160(ctx context.Context, format string, localVarOptionals *CommonApiBasicApiAuthority2160Opts) ([]PtxServiceDtoSharedSpecificationV2BaseAuthority, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PtxServiceDtoSharedSpecificationV2BaseAuthority
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/Authority"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PtxServiceDtoSharedSpecificationV2BaseAuthority
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CommonApiService 取得營運業者資料
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format 指定來源格式
 * @param optional nil or *CommonApiBasicApiOperator2162Opts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.String) -  跳過前幾筆
@return []PtxServiceDtoSharedSpecificationV2BaseOperator
*/

type CommonApiBasicApiOperator2162Opts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.String
}

func (a *CommonApiService) BasicApiOperator2162(ctx context.Context, format string, localVarOptionals *CommonApiBasicApiOperator2162Opts) ([]PtxServiceDtoSharedSpecificationV2BaseOperator, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PtxServiceDtoSharedSpecificationV2BaseOperator
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/Operator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PtxServiceDtoSharedSpecificationV2BaseOperator
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
CommonApiService 取得資料提供平台資料
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format 指定來源格式
 * @param optional nil or *CommonApiBasicApiProvider2161Opts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.String) -  跳過前幾筆
@return []PtxServiceDtoSharedSpecificationV2BaseProvider
*/

type CommonApiBasicApiProvider2161Opts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.String
}

func (a *CommonApiService) BasicApiProvider2161(ctx context.Context, format string, localVarOptionals *CommonApiBasicApiProvider2161Opts) ([]PtxServiceDtoSharedSpecificationV2BaseProvider, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []PtxServiceDtoSharedSpecificationV2BaseProvider
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/Provider"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []PtxServiceDtoSharedSpecificationV2BaseProvider
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
